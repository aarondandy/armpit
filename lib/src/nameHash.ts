import { createHash, createHmac } from "node:crypto";
import { CallableClassBase } from "./utils.js";

export interface NameHash {
  (length?: number): string;
}

type EncodingKind = "alphanumeric" | "hex" | "numeric" | "alpha";

interface NameHashOptions {
  type?: EncodingKind,
  defaultLength?: number
}

function isNameHashOptions(value: any): value is NameHashOptions {
  return value != null && typeof value === "object";
}

export class NameHash extends CallableClassBase {

  private static calculateSha256Hash(values: any[]) {
    const valuesHasher = createHash("sha256");
    for (const value of values) {
      if (typeof value === "string") {
        valuesHasher.update(value, "utf8");
      } else {
        valuesHasher.update(value);
      }
    }

    return valuesHasher.digest();
  }

  private static calculateSha256Hmac(prk: Buffer, input: Buffer) {
    const hmac = createHmac("sha256", prk);
    hmac.update(input);
    const buffer = hmac.digest();

    if (!(buffer.length > 0)) {
      throw new Error("Hash failure");
    }

    return buffer;
  }

  private static packBufferIntoInt(buffer: Buffer): BigInt {
    let result = 0n;
    for (let i = 0; i < buffer.length; i++) {
      result |= BigInt(buffer[i]) << BigInt(i * 8);
    }

    return result;
  }

  private static getDefaultLength(type: EncodingKind) {
    switch (type) {
      case "alphanumeric":
      case "alpha":
        return 3;
      default:
        return 4;
    }
  }

  private static toTextHex(data: Buffer) {
    return this.toTextBase(data, "hex");
  }

  private static toTextBase(data: Buffer, type: Extract<EncodingKind, "numeric" | "alpha" | "alphanumeric" | "hex">): string {
    let padCharacter = "0";
    let resultLength: number;
    let radix: number;

    if (data.length !== 32) {
      throw new Error("Unexpected data size");
    }

    switch (type) {
      case "hex":
        resultLength = data.length * 2;
        radix = 16;
        break;
      case "numeric":
        resultLength = 77;
        radix = 10;
        break;
      case "alpha":
        resultLength = 54;
        radix = 26;
        padCharacter = "a";
        break;
      case "alphanumeric":
      default:
        resultLength = 49;
        radix = 36;
        break;
    }

    let result = NameHash.packBufferIntoInt(data).toString(radix);

    // Each buffer should produce a specific number of characters.
    if (result.length > resultLength) {
      // Sometimes we may get a 50th character out of it. It isn't a full byte so drop it.
      result = result.slice(0, resultLength);
    } else if (result.length < resultLength) {
      // Sometimes we may get a value with high order zeros, so we must pad it.
      result = result.padStart(resultLength, padCharacter);
    }

    let parts = result.split("");

    if (type === "alpha") {
      parts = parts.map(char => {
        let code = char.charCodeAt(0);
        if (code >= 48 && code <= 57) {
          code += 49;
        } else if (code >= 97 && code <= 112) {
          code += 10;
        }

        return String.fromCharCode(code);
      });
    }

    // Hashes of different lengths but sourced from the same inputs should sort together.
    // Because the resulting values are effectively text which is sorted left to right,
    // the lower order values should be on the left so that additional generated hash bytes
    // are eventually appended to the right of the string. A simple reverse after building
    // the value should work.
    // Whole blocks are generated by this code so this may not matter technically, doing
    // the reverse now gives more flexibility for future implementations, I hope.
    parts = parts.reverse();

    return parts.join("");
  }

  #values: string[];
  #options: {
    type: EncodingKind,
    defaultLength: number,
  };
  #cached: string | null;

  constructor(value: string);
  constructor(value: string, options: NameHashOptions);
  constructor(...values: string[]);
  constructor(...args: [...values: string[], options: NameHashOptions]);
  constructor(...args: string[] | [...values: string[], options: NameHashOptions]) {
    super();

    let options: NameHashOptions | null;
    let values: string[];

    if (args.length === 0) {
      options = null;
      values = [];
    } else {
      const lastArg = args[args.length - 1];
      if (isNameHashOptions(lastArg)) {
        values = args.slice(0, args.length - 1) as string[];
        options = lastArg;
      }
      else {
        values = args as string[];
        options = null;
      }
    }

    const type = options?.type ?? "alphanumeric";

    this.#values = values;
    this.#options = {
      type,
      defaultLength: Math.max(options?.defaultLength ?? NameHash.getDefaultLength(type), 1)
    };

    this.#cached = null;
  }

  concat(value: string) {
    return new NameHash(...this.#values, value, this.#options);
  }

  toString(length?: number) {
    length = length != null && length > 0 ? length : this.#options.defaultLength;
    let result = this.#cached;
    if (result == null || result.length < length) {
      result = this.#buildHashText(length);
      this.#cached = result;
    }

    if (result.length > length) {
      result = result.slice(0, length);
    }

    return result;
  }

  protected fnImpl(length?: number) {
    return this.toString(length);
  }

  #buildHashText(minTextLength: number): string {
    let hashValue = "";
    let iteration = 1;
    let tBuffer : Buffer | null = null;

    const pseudoRandomKey = NameHash.calculateSha256Hash(this.#values);

    while (hashValue.length < minTextLength) {
      let hmacInputBuffer = Buffer.from([iteration % 256]);
      if (tBuffer) {
        hmacInputBuffer = Buffer.concat([tBuffer, hmacInputBuffer]);
      }

      tBuffer = NameHash.calculateSha256Hmac(pseudoRandomKey, hmacInputBuffer);

      hashValue += this.#options.type === "hex"
        ? NameHash.toTextHex(tBuffer)
        : NameHash.toTextBase(tBuffer, this.#options.type);

      iteration++;
    }

    return hashValue;
  }

}
